import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler

# Define indicator functions
def EMA(data, windowSize):
    return data.ewm(span=windowSize, min_periods=windowSize, adjust=False).mean()

def SMA(data, windowSize):
    return data.rolling(window=windowSize, min_periods=windowSize).mean()

def WMA(data, windowSize):
    weights = list(range(1, windowSize + 1))
    denom = np.sum(weights)
    return (data.rolling(window=windowSize, min_periods=windowSize)
                .apply(lambda x: np.sum(weights * x) / denom, raw=False))

def HMA(data, windowSize):
    return WMA((2 * WMA(data, int(windowSize / 2)) - WMA(data, windowSize)), int(np.sqrt(windowSize)))

def MACD(close):
    return EMA(close, 12) - EMA(close, 26)

def TypicalPrice(high, low, close):
    return (high + low + close) / 3

def CCI(typicalPrice):
    smatp = EMA(typicalPrice, 20)
    avgDev = typicalPrice.rolling(window=20, min_periods=20).std()
    return (typicalPrice - smatp) / (0.015 * avgDev)

def StochasticOscillator(close, high, low):
    return 100 * (close - low.rolling(window=14, min_periods=14).min()) / (
            high.rolling(window=14, min_periods=14).max() - low.rolling(window=14, min_periods=14).min())

def RSI(close):
    delta = close.diff()
    up = delta.copy()
    up[delta <= 0] = 0.0
    down = abs(delta.copy())
    down[delta > 0] = 0.0
    roll_up = EMA(up, 14)
    roll_down = EMA(down, 14)
    RS = roll_up / roll_down
    return 100.0 - (100.0 / (1.0 + RS))

def ROC(close, window):
    return 100 * close.diff(window - 1) / close.shift(window - 1)

def PPO(close):
    return 100 * MACD(close) / EMA(close, 26)

def KST(close):
    RCMA1 = SMA(ROC(close, 10), 10)
    RCMA2 = SMA(ROC(close, 15), 10)
    RCMA3 = SMA(ROC(close, 20), 10)
    RCMA4 = SMA(ROC(close, 30), 15)
    return SMA((RCMA1 + 2 * RCMA2 + 3 * RCMA3 + 4 * RCMA4), 9)

def BollingerBandUp(typicalPrice):
    return SMA(typicalPrice, 20) + 2 * np.std(typicalPrice.iloc[-20:])

def BollingerBandMiddle(typicalPrice):
    return SMA(typicalPrice, 20)

def BollingerBandDown(typicalPrice):
    return SMA(typicalPrice, 20) - 2 * np.std(typicalPrice.iloc[-20:])

# Load data
# data = pd.read_csv('/path/to/your/new_data.csv', parse_dates=['time'])
# data = pd.read_pickle("/home/hmsb/neuraltrade-backend/data/rawData/USD_CAD_H1.pkl")

# Create the target column
# data['Target'] = (data['mid_c'].shift(-1) > data['mid_c']).astype(int)

# Remove NaN values
# data.dropna(inplace=True)

# Feature extraction from time
# data['hour'] = data['time'].dt.hour
# data['day_of_week'] = data['time'].dt.dayofweek

# Calculate technical indicators
# data['EMA_12'] = EMA(data['mid_c'], 12)
# data['EMA_26'] = EMA(data['mid_c'], 26)
# data['SMA_20'] = SMA(data['mid_c'], 20)
# data['WMA_20'] = WMA(data['mid_c'], 20)
# data['HMA_20'] = HMA(data['mid_c'], 20)
# data['MACD'] = MACD(data['mid_c'])
# data['TypicalPrice'] = TypicalPrice(data['mid_h'], data['mid_l'], data['mid_c'])
# data['CCI'] = CCI(data['TypicalPrice'])
# data['StochasticOscillator'] = StochasticOscillator(data['mid_c'], data['mid_h'], data['mid_l'])
# data['RSI'] = RSI(data['mid_c'])
# data['ROC'] = ROC(data['mid_c'], 20)
# data['PPO'] = PPO(data['mid_c'])
# data['KST'] = KST(data['mid_c'])
# data['BollingerBandUp'] = BollingerBandUp(data['TypicalPrice'])
# data['BollingerBandMiddle'] = BollingerBandMiddle(data['TypicalPrice'])
# data['BollingerBandDown'] = BollingerBandDown(data['TypicalPrice'])

# save data to csv
# data.to_csv('/home/hmsb/neuraltrade-backend/data/newData', index=False)

# # Drop NaN values generated by technical indicators
# data.dropna(inplace=True)

# # Select features
# features = data.drop(columns=['time', 'Target'])

# # Normalize/Standardize the data
# scaler = StandardScaler()
# features_scaled = scaler.fit_transform(features)

# # Your features_scaled and data['Target'] are ready for model training
